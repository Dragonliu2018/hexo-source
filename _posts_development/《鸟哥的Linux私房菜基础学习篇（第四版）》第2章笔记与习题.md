---
title: 《鸟哥的Linux私房菜基础学习篇（第四版）》第2章笔记与习题
tags:
categories:
  - 阅读
  - [操作系统, Linux]
toc: true
mathjax: true
top: false
comments: true
copyright: true
date: 2022-07-24 14:45:20
---

> 第2章：主机规划与磁盘分区

# 1 笔记

## 1.1 分区表格式

### 1.1.1 MBR（MS-DOS）分区表

早期的 Linux 系统为了兼容 Windows 的磁盘，因此使用的是支持 Windows 的 MBR(Master Boot Record, 主引导记录) 的方式来处理启动引导程序与分区表。而启动引导程序纪录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是 512bytes 的大小 (旧的磁盘扇区都是 512bytes)，所以说，第一个扇区的 512bytes 会有这两个数据：

* 主引导纪录(Master Boot Record, MBR)：可以安装启动引导程序的地方，有 446 bytes 
* 分区表(partition table)：记录整块硬盘分区的状态，有 64 bytes，最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的柱面号码。

#### 1.1.1.1 主要分区

示意图如下图所示：

<img src="https://s2.loli.net/2022/07/25/rT5yQlPSRLsf7Yc.png" width = "500" height = "500" alt="图片名称" align=center id=211 />

假设硬盘设备文件名为`/dev/sda`时，那么这四个分区在Linux系统中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与该分区所在的位置有关。

* `P1:/dev/sda1`
* `P2:/dev/sda2`
* `P3:/dev/sda3`
* `P4:/dev/sda4`

分区表的四个分区的记录被称为主要(Primary)或扩展(Extended)分区。

其实所谓的『分区』只是针对那个 64 bytes 的分区表进行设定而已。

分区的最小单位『通常』为柱面(cylinder)。

当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。

#### 1.1.1.2 主要分区+扩展分区

示意图如下图所示：

<img src="https://s2.loli.net/2022/07/25/OgnT9G1leRIqDfh.png" width = "500" height = "500" alt="图片名称" align=center id=212 />

硬盘的四个分区记录区仅使用到两个，P1 为主要分区，而 P2 则为扩展分区。扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。然后我们可以透过扩展分区所指向的那个区块继续作分区的记录。

如上图右下方那个区块有继续分区出五个分区， 这五个由扩展分区继续切出来的分区，就被称为逻辑分区(logical partition)。

上述的分区在 Linux 系统中的设备文件名分别如下：

* `P1:/dev/sda1`
* `P1:/dev/sda2`
* `P1:/dev/sda5`
* `P1:/dev/sda6`
* `P1:/dev/sda7`
* `P1:/dev/sda8`
* `P1:/dev/sda9`

**前面四个号码都是保留给 Primary 或 Extended 用的，所以逻辑分区的设备名称号码就由 5 号开始。**

#### 1.1.1.3 主要分区 vs 扩展分区 vs 逻辑分区

* 主要分区与扩展分区最多可以有四个(硬盘的限制) 
* 扩展分区最多只能有一个(操作系统的限制) 
* 逻辑分区是由扩展分区持续切割出来的分区；
* 能够被格式化后，作为数据存取的分区为主要分区与逻辑分区，扩展分区无法格式化；
* 逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制；
* 如果扩展分区被破坏，所有逻辑分区将会被删除， 因为逻辑分区的信息都记录在扩展分区里面；
* 考虑到磁盘的连续性，一般建议将 Extended 的柱面号码分配在最后面的柱面内。

#### 1.1.1.4 MBR缺点

* 操作系统无法使用 2.2T 以上的磁盘容量；虽然 Linux kernel 现在已经可以透过某些机制让磁盘分区高过 63 个以上，但是这样就得要割出较多个分区，不易操作。`见博客 MBR分区表为什么最大只能识别2TB硬盘容量`
* MBR 仅有一个区块，若被破坏后，经常无法或很难恢复。
* MBR 内的存放启动引导程序的区块仅 446bytes，无法存储较多的程序代码。

### 1.1.2 GPT（GUID partition table）磁盘分区表

因为过去一个扇区大小就是 512bytes 而已，不过目前已经有 4K 的扇区设计出现。为了兼容于所有的磁盘，因此在扇区的定义上面， 大多会使用所谓的逻辑区块地址(Logical Block Address, LBA)来处理。GPT 将磁盘所有区块以此 LBA(默认为 512bytes) 来规划，而第一个 LBA 称为 LBA0 (从0 开始编号)。 

与 MBR 仅使用第一个 512bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息。同时与过去 MBR 仅有一的区块，被干掉就死光光的情况不同， GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份。这样或许会比较安全些吧！详细的结构如下图所示：

<img src="https://s2.loli.net/2022/07/25/rMfqtWbePZXUKJn.png" width = "400" height = "500" alt="图片名称" align=center id=215 />

**LBA0 (MBR 兼容区块)**

与 MBR 模式相似的，这个兼容区块也分为两部分，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的启动引导程序。而在原本的分区表的记录区内，这个兼容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘。

**LBA1 (GPT 表头纪录)**

这部分纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 (就是前面谈到的在最后 34 个 LBA 区块) 放置的位置， 同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，还可以透过这个记录区来取得备份的 GPT(磁盘最后的那个备份区块) 来恢复 GPT 的正常运作。

**LBA2-33 (实际纪录分区信息处)** 

从 LBA2 区块开始，每个 LBA 都可以记录 4 组分区记录，所以在默认的情况下，总共可以有 4*32 = 128 组分区记录。因为每个 LBA 有 512bytes，因此每组记录用到 128 bytes 的空间，除了每组记录所需要的标识符与相关的记录之外，GPT 在每组记录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区来说， 他的最大容量限制就会在$2^{64} * 512bytes = 2^{63} * 1Kbytes = 2^{33}*TB = 8 ZB$，要注意 $1ZB = 2^{30}TB$

***

现在 GPT 分区默认可以提供多达 128 组记录，而在 Linux 本身的内核设备记录中，针对单一磁盘来说，虽然过去最多只能到达 15 个分区，不过由于 Linux kernel 透过 udev 等方式的处理，现在 Linux 也已经没有这个限制在了。 此外，GPT 分区已经没有所谓的主、扩展、逻辑分区的概念，既然每笔纪录都可以独立存在，当然每个都可以视为是主分区，每一个分区都可以拿来格式化使用。

## 1.2 启动程序

### 1.2.1 **BIOS** **搭配** **MBR/GPT** 的启动流程

**整个启动流程到操作系统之前**：

1. **BIOS**：开机主动执行的固件，会认识第一个可启动的设备
2. **MBR**：第一个可启动设备的第一个扇区内的主引导记录块，内含启动引导代码；
3. **启动引导程序(boot loader)**：一个可读取内核文件来执行的软件；
4. **内核文件**：开始启动操作系统

**Boot loader 的主要任务**：

* **提供选项**：用户可以选择不同的启动选项，这也是多重引导的重要功能；
* **加载内核文件**：直接指向可使用的程序区段来开始操作系统；
* **转交其他启动引导程序**：将启动管理功能转交给其他启动引导程序负责。

**多重引导**：

启动引导程序除了可以安装在 MBR 之外， 还可以安装在每个分区的启动扇区(boot sector)。

假设你的个人计算机只有一个硬盘，里面切成四个分区，其中第一、二分区分别安装了 Windows 及 Linux， 你要如何在开机的时候选择用 Windows 还是 Linux 开机呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的启动引导程序，那么整个流程如下：

<img src="https://s2.loli.net/2022/07/25/kVbaMHKR6CWAoz1.png" width = "600" height = "400" alt="图片名称" align=center id=216 />

* 每个分区都拥有自己的启动扇区(boot sector)
* 图中的系统分区为第一及第二分区，
* 实际可启动的内核文件是放置到各分区内的
* loader 只会认识自己的系统分区内的可启动的内核文件，以及其他 loader 而已；
* loader 可直接指向或者是间接将管理权转交给另一个管理程序。

**如果要安装多重引导，最好先安装 Windows 再安装 Linux，原因如下：**

* Linux 在安装的时候，你可以选择启动引导程序安装在 MBR 或各别分区的启动扇区， 而且 Linux 的loader 可以手动设定选单(就是上图的 M1, M2...)，所以你可以在 Linux 的 boot loader 里面加入 Windows 开机的选项；
* Windows 在安装的时候，他的安装程序会主动的覆盖掉 MBR 以及自己所在分区的启动扇区，你没有选择的机会， 而且他没有让我们自己选择选单的功能。

因此，如果先安装 Linux 再安装 Windows 的话，那 MBR 的开机管理程序就只会有 Windows 的项目，而不会有 Linux 的项目 (因为原本在 MBR 内的 Linux 的启动引导程序就会被覆盖掉)。 那需要重新安装 Linux 一次吗？当然不需要，你只要用尽各种方法来处理 MBR 的内容即可。 例如利用 Linux 的恢复模式来修复 MBR。

### 1.2.2 **UEFI BIOS** **搭配** **GPT** 启动的流程

我们现在知道 GPT 可以提供到 64bit 的寻址，然后也能够使用较大的区块来处理启动引导程序，但是 BIOS 其实不懂 GPT 。还得要通过 GPT 提供兼容模式才能够读写这个磁盘设备，而且 BIOS 仅为 16 位的程序，在与现阶段新的操作系统接轨方面有点弱掉。为了解决这个问题，因此就有了 UEFI (Unified Extensible Firmware Interface) 这个统一可扩展固件接口的产生。

|       比较项目       |                          传统 BIOS                           |        UEFI        |
| :------------------: | :----------------------------------------------------------: | :----------------: |
|     使用程序语言     |                           汇编语言                           |       C 语言       |
|     硬件资源控制     | 使用中断 (IRQ) 管理<br/>不可变的内存存取<br/>不可变得输入/输出存取 | 使用驱动程序与协议 |
|    处理器运作环境    |                            16 位                             |    CPU 保护模式    |
|       扩充方式       |                        通过 IRQ 连接                         |  直接加载驱动程序  |
|    第三方厂商支持    |                             较差                             | 较佳且可支持多平台 |
|      图形化能力      |                             较差                             |        较佳        |
| 内置简化操作系统环境 |                            不支持                            |        支持        |

与 BIOS 模式相比，虽然 UEFI 可以直接取得 GPT 的分区表，不过最好依旧拥有 BIOS boot 的分区支持， 同时，为了与 windows 兼容，并且提供其他第三方厂商所使用的 UEFI 应用程序存储的空间，你必须要格式化一个 FAT 的文件系统分区， 大约提供 512MB 到 1G 左右的容量，以让其他 UEFI 执行较为方便。

## 1.3 文件系统与目录树的关系(挂载)

所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下； 也就是说，进入该目录就可以读取该分区的意思。这个操作称为『挂载』，那个进入点的目录我们称为『挂载点』。

# 2 习题

略
